#!/usr/bin/env python3
import argparse
import json
import logging
import os
from collections import defaultdict
from pathlib import Path

from onepassword import OnePassword


class SecretGenerator:
    """A basic secret generator that manages a secrets directory containing
    per-component secret export files from from Vault, as generated by
    read_secrets.sh.

    Parameters
    ----------
    environment : str
        The name of the environment (the environment's domain name).
    regenerate : bool
        If `True`, any secrets that can be generated by the SecretGenerator
        will be regenerated.
    """

    def __init__(self, environment, regenerate):
        self.secrets = defaultdict(dict)
        self.environment = environment
        self.regenerate = regenerate

    def generate(self):
        """Generate secrets for each component based on the `secrets`
        attribute, and regenerating secrets if applicable when the
        `regenerate` attribute is `True`.
        """
        # self._pull_secret()
        pass

    def load(self):
        """Load the secrets files for each RSP component from the
        ``secrets`` directory.

        This method parses the JSON files and persists them in the ``secrets``
        attribute, keyed by the component name.
        """
        if Path("secrets").is_dir():
            for f in Path("secrets").iterdir():
                print(f"Loading {f}")
                component = os.path.basename(f)
                self.secrets[component] = json.loads(f.read_text())

    def save(self):
        """For each component, save a secret JSON file into the secrets
        directory.
        """
        os.makedirs("secrets", exist_ok=True)

        for k, v in self.secrets.items():
            with open(f"secrets/{k}", "w") as f:
                f.write(json.dumps(v))

    def input_field(self, component, name, description):
        default = self.secrets[component].get(name, "")
        prompt_string = (
            f"[{component} {name}] ({description}): [current: {default}] "
        )
        input_string = input(prompt_string)

        if input_string:
            self.secrets[component][name] = input_string

    def input_file(self, component, name, description):
        current = self.secrets.get(component, {}).get(name, "")
        print(f"[{component} {name}] ({description})")
        print(f"Current contents:\n{current}")
        prompt_string = "New filename with contents (empty to not change): "
        fname = input(prompt_string)

        if fname:
            with open(fname, "r") as f:
                self.secrets[component][name] = f.read()

    def _get_current(self, component, name):
        if not self._exists(component, name):
            return None

        return self.secrets[component][name]

    def _set(self, component, name, new_value):
        self.secrets[component][name] = new_value

    def _exists(self, component, name):
        return component in self.secrets and name in self.secrets[component]

    def _set_generated(self, component, name, new_value):
        if not self._exists(component, name) or self.regenerate:
            self._set(component, name, new_value)

    def _pull_secret(self):
        self.input_file(
            "pull-secret",
            ".dockerconfigjson",
            ".docker/config.json to pull images",
        )


class OnePasswordSecretGenerator(SecretGenerator):
    """A secret generator that syncs 1Password secrets into a secrets directory
    containing per-component secret export files from Vault (as generated
    by read_secrets.sh).

    Parameters
    ----------
    environment : str
        The name of the environment (the environment's domain name).
    regenerate : bool
        If `True`, any secrets that can be generated by the SecretGenerator
        will be regenerated.
    """

    def __init__(self, environment, regenerate):
        super().__init__(environment, regenerate)
        self.op_secrets = {}
        self.op = OnePassword()
        self.parse_vault()

    def parse_vault(self):
        """Parse the 1Password vault and store secrets applicable to this
        environment in the `op_secrets` attribute.

        This method is called automatically when initializing a
        `OnePasswordSecretGenerator`.
        """
        items = self.op.list_items("Build and Deploy")

        for i in items:
            key = None
            environments = []
            uuid = i["uuid"]
            doc = self.op.get_item(uuid=uuid)

            logging.debug(f"Looking at {uuid}")
            logging.debug(f"{doc}")

            for section in doc["details"]["sections"]:
                if "fields" not in section:
                    continue

                for field in section["fields"]:
                    if field["t"] == "generate_secrets_key":
                        if key is None:
                            key = field["v"]
                        else:
                            raise Exception(
                                "Found two generate_secrets_keys for {key}"
                            )
                    elif field["t"] == "environment":
                        environments.append(field["v"])

            # If we don't find a generate_secrets_key somewhere, then we
            # shouldn't bother with this document in the vault.
            if not key:
                logging.debug(
                    "Skipping because of no generate_secrets_key, %s", uuid
                )
                continue

            # The type of secret is either a note or a password login.
            # First, check the notes.
            secret_value = doc["details"]["notesPlain"]

            # If we don't find anything, pull the password from a login item.
            if not secret_value:
                for f in doc["details"]["fields"]:
                    if f["designation"] == "password":
                        secret_value = f["value"]

            logging.debug("Environments are %s for %s", environments, uuid)

            if self.environment in environments:
                self.op_secrets[key] = secret_value
                logging.debug("Storing %s (matching environment)", uuid)
            elif not environments and key not in self.op_secrets:
                self.op_secrets[key] = secret_value
                logging.debug("Storing %s (applicable to all envs)", uuid)
            else:
                logging.debug("Ignoring %s", uuid)

    def input_field(self, component, name, description):
        """Query for a secret's value from 1Password (`op_secrets` attribute).

        This method overrides `SecretGenerator.input_field`, which prompts
        a user interactively.
        """
        key = f"{component} {name}"
        if key not in self.op_secrets:
            raise Exception(f"Did not find entry in 1Password for {key}")

        self.secrets[component][name] = self.op_secrets[key]

    def input_file(self, component, name, description):
        """Query for a secret file from 1Password (`op_secrets` attribute).

        This method overrides `SecretGenerator.input_file`, which prompts
        a user interactively.
        """
        return self.input_field(component, name, description)

    def generate(self):
        """Generate secrets, updating the `secrets` attribute.

        This method first runs `SecretGenerator.generate`, and then
        automatically generates secrets for any additional components
        that were identified in 1Password.

        If a secret appears already, it is overridden with the value in
        1Password.
        """
        super().generate()

        for composite_key, secret_value in self.op_secrets.items():
            item_component, item_name = composite_key.split()

            logging.debug(
                "Updating component: %s/%s", item_component, item_name
            )
            self.input_field(item_component, item_name, "")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="generate_secrets")
    parser.add_argument(
        "--op",
        default=False,
        action="store_true",
        help="Load secrets from 1Password",
    )
    parser.add_argument(
        "--verbose", default=False, action="store_true", help="Verbose logging"
    )
    parser.add_argument(
        "--regenerate",
        default=False,
        action="store_true",
        help="Regenerate random secrets",
    )
    parser.add_argument("environment", help="Environment to generate")
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig()

    if args.op:
        sg = OnePasswordSecretGenerator(args.environment, args.regenerate)
    else:
        sg = SecretGenerator(args.environment, args.regenerate)

    sg.load()
    sg.generate()
    sg.save()
